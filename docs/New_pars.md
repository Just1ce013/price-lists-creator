# Описание файла new_pars.py

## Предопределенные массивы и словари
Имя | Описание
---------- | ---------- 
**category_names** | Словарь, предназначенный для определения корректного названия категории по подстроке из URL
**category_ids** | Словарь, которые жестко определяет *id* для категории.
**fields_for_spl** | Имена полей для выгрузки *SPL*.
**fields_for_zzap** | Имена полей для выгрузки *ZZAP*.
**fields_for_avito** | Имена полей для выгрузки *AVITO*.
**fields_for_drom** | Имена полей для выгрузки *DROM*.
**fields_for_2gis** | Имена полей для выгрузки *2GIS*.
**stop_categories** | Категории, которые не должны участвовать в выгрузке *SPL*.

## Глобальные переменные

`URL` - ссылка на каталог запчастей сайта tdbovid.ru.

`BASE_URL` - ссылка на главную страницу сайта tdbovid.ru.

>Переменная URL используется для получения HTML разметки страницы с помощью метода get_page, из которого в дальнейшем с помощью метода get_catalog собирается массив словарей с наименованиями и ссылками на категории.

`today` - массив вида ("год", "месяц", день"). Используется в названии файлов.

`filename` - название файлов, составленное по шаблону "tdbovid_день_месяц_год_названиеРесурса.форматФайла".

`tdbovid_adapter` - HTTP-адаптер, у которого также указан параметр max_retries, который определяет количество попыток получить ответ на запрос.

`session.mount` - служит указанием, что для каждого запроса, начинающегося с BASE_URL будет использоваться tdbovid_adapter.

`tree` - XML-дерево.

## Краткое описание предназначения методов
Имя | Описание | Параметры
---------- | ---------- | ----------
write_column_names | Используется для записи в xlsx-файл названий колонок | `worksheet` - лист эксель-файла<br />`names` - массив имен колонок
write_data | Запись данных в xlsx-файл | `worksheet` - лист эксель-файла<br />`current_row` - номер строки, с которой нужно начинать записывать данные (по сути константа, равная 1)<br />`data` - массив данных<br />`column_count` - количество колонок
pic_links | Из переданного массива ссылок на картинки составляет одну строку с запятой в качестве разделителя, фильтруя при этом маленькие и средние изображения, оставляя лишь большие | `imgs` - массив ссылок
obzhee | Получение и обработка данных для выгрузок на *ZZAP, SPL, DROM, AVITO, 2GIS* |
sberMarket_xml | Создание XML-файла для сбера |
sberMarket_xls | Создание XLSX-файла для сбера |
create_EAN13 | Генератор EAN13 | `detail_id` - уникальный идентификатор запчасти 

## Obzhee
Получение и обработка информации в методе реализована через бесконечный цикл, который прерывается, когда в ответ на запрос ничего не возвращается. Массивы данных передаются в методы, которые записывают всё в эксель-файлы.
```python
...
while True:
    details = session.get(f"http://tdbovid.ru:3500/api/position?start={start}&limit={limit}").json()
    if len(details) == 0:
        write_data(spl_worksheet, 1, data_for_spl, len(fields_for_spl))
        write_data(gis_worksheet, 1, data_for_2gis, len(fields_for_2gis))
        write_data(drom_worksheet, 1, data_for_drom, len(fields_for_drom))
        write_data(avito_worksheet, 1, data_for_avito, len(fields_for_avito))
        write_data(zzap_worksheet, 1, data_for_zzap, len(fields_for_zzap))
        spl_workbook.close()
        gis_workbook.close()
        drom_workbook.close()
        avito_workbook.close()
        zzap_workbook.close()
        break;
...
```
Данные о запчастях получаются порциями по 1000, так как `limit = 1000`.
Для обхода этих массивов, каждый из них попадает в цикл for, в начале которого создаются флаги булевого типа, по которым в конце определяется, в какую выгрузку должна попасть запчасть, а в какую нет. Также проверяется несколько общих условий, в случае попадания запчасти под одно из них, начинается следующая итерация цикла for, а текущая запчасть, соответственно не попадает ни в одну из выгрузок
```python
for detail in details:
    spl_check = True
    gis_check = True
    drom_check = True
    avito_check = True
    zzap_check = True
    #Общие проверки
    if detail["searchable"] == 0 or detail["published"] == 0:
	continue
    if detail["code"] == None or detail["code"] == "":
	continue
    if detail["article"] == None or detail["article"] == "" or detail["article"].find("...") > 0:
	continue
    if len(detail["storage"]) == 0:
	continue 
```
Далее проводится проверка категории, к которой относится запчасть.
> Проверяется, не находится ли категория в стоп-листе для SPL
Если запчасть удовлетворяет данному условию, то она автоматически не попадает в выгрузку SPL. Ну а если категории нет в ключах словаря *category_names*, то она выбывает из всех выгрузок и начинается следующая итерация цикла
```python
category = list(filter(None, detail["uri"].split('/')))[1]
if category in category_names.keys():
    if category_names[category] in stop_categories:
        spl_check = False
    else:
        continue
```
После собираются данные о наличии запчасти в магазинах и на складах.
> В некоторых выгрузках необходимо указывать наличие лишь в магазине и на складе на Линейной, в то же время в оставшихся выгрузках необходимо наличие во всех магазинах и на складах
```python
nalichie_lineynaya = 0
store = {}
nalichie_obzhee = 0
for el in detail["storage"]:
    #Проверка для ZZap и spl
    amount = str(el["amount"])
    if el["namestorage"] == "г.Челябинск, ул.Линейная, 98":
        if amount[0] != "-":
	    if amount.find("\xa0") > 0:
	        nalichie_lineynaya = round(float(amount[:amount.find("\xa0")]))
	        if el["namestorage"] in store.keys():
		    store[el["namestorage"]] += nalichie_lineynaya
	        else:
		    store[el["namestorage"]] = nalichie_lineynaya
	    else:
	        nalichie_lineynaya += round(float(amount.replace(",",".")))
	        if el["namestorage"] in store.keys():
		    store[el["namestorage"]] += nalichie_lineynaya
	        else:
		    store[el["namestorage"]] = nalichie_lineynaya
	    nalichie_obzhee += nalichie_lineynaya
    #Для Drom и 2gis
    else:
        if amount[0] == "-":
	    store[el["namestorage"]] = 0
	    continue
        if amount.find("\xa0") > 0:
	    count = round(float(amount[:amount.find("\xa0")]))
	    store[el["namestorage"]] = count
        else:
	    count = round(float(amount.replace(',','.')))
	    store[el["namestorage"]] = count
        nalichie_obzhee += count    

if nalichie_lineynaya == 0:
    spl_check = False
    zzap_check = False

if nalichie_obzhee == 0:
    drom_check = False
    gis_check = False
    avito_check = False
```
> В конце наглядно показано, для каких выгрузок какое наличие требуется

Далее из массива ссылок получаем строку с разделителем-запятой с помощью метода pic_links
```python
pic_links = ""
if len(imgs) > 0:
    count = len(imgs)/3
    for el in imgs:
        if el["url"].find("small") == -1 and el["url"].find("medium") == -1:
	    url = BASE_URL + el["url"]
	    pic_links += url
	    if count > 1:
	        pic_links += ", "
	        count = count - 1
return pic_links
```
Осталось лишь добавить в массив данных для выгрузок запчасть, если, конечно, флаги, которые устанавливались в самом начале цикла for всё еще `True`. На примере добавления в массив для 2ГИС
```python
if gis_check: 
    data_for_2gis.append([
	str(date.today()),
	category_names[category],
	detail["article"],
	BASE_URL + detail["uri"],
	detail["title"],
	detail["code"],
	detail["external_id"],
	detail["title"],
	detail["price"],
	nalichie_obzhee,
	store.get("г.Челябинск, ул.Линейная, 98", 0),
	store.get("г.Челябинск, Троицкий тр., 66", 0),
	store.get("г.Магнитогорск, ул.Кирова, 100", 0),
	store.get("г.Магнитогорск, ул.Заводская, 1/2", 0),
	store.get("г.Красноярск, ул. 2-я Брянская, 34, стр. 2", 0),
	links    
    ])
```
**Также у `Авито` есть еще пара особенностей:**
1. В выгрузку не должны попадать запчасти, цена которых менее 500 рублей.
2. У авито есть список символов, которые не перевариваются системой и выгрузка не принимается
```python
if detail["price"] <= 500:
    avito_check = False                    
replace_values = ['*', '(', ')', '.', ',', ';', '№', '/', '–', '#', '=', '"', '-']
a = detail["article"]
for rv in replace_values:
    a = a.replace(rv, ' ') 
if avito_check: 
    data_for_avito.append([
	detail["external_id"],
	'Package',
	'Free',
	'Да',
	'Светлана Жданова',
	'+7 (351) 200-27-46',
	'Россия, Челябинская область, Челябинск, Линейная улица, 98',
	'Москва и Московская область | Москва и Московская область, Москва | Санкт-Петербург и Ленинградская область | Санкт-Петербург и Ленинградская область, Санкт-Петербург | Башкортостан | Башкортостан, Уфа | Курганская область | Курганская область, Курган | Оренбургская область | Оренбургская область, Оренбург | Пермский край | Пермский край, Пермь | Самарская область, Самара | Самарская область | Свердловская область | Свердловская область, Екатеринбург | Татарстан | Татарстан, Казань | Тюменская область | Тюменская область, Тюмень | Челябинская область | Челябинская область, Челябинск | Челябинская область, Агаповка | Челябинская область, Аргаяш | Челябинская область, Аша | Челябинская область, Бакал | Челябинская область, Бердяуш | Челябинская область, Бобровка | Челябинская область, Бреды | Челябинская область, Бродокалмак | Челябинская область, Варна | Челябинская область, Верхнеуральск | Челябинская область, Верхний Уфалей | Челябинская область, Вишневогорск | Челябинская область, Долгодеревенское | Челябинская область, Еманжелинка | Челябинская область, Еманжелинск | Челябинская область, Еткуль | Челябинская область, Зауральский | Челябинская область, Златоуст | Челябинская область, Канашево | Челябинская область, Карабаш | Челябинская область, Карталы | Челябинская область, Касли | Челябинская область, Катав-Ивановск | Челябинская область, Кизильское | Челябинская область, Коелга | Челябинская область, Копейск | Челябинская область, Коркино | Челябинская область, Красногорский | Челябинская область, Кропачево | Челябинская область, Кунашак | Челябинская область, Куса | Челябинская область, Кыштым | Челябинская область, Локомотивный | Челябинская область, Магнитка | Челябинская область, Магнитогорск | Челябинская область, Межевой | Челябинская область, Межозерный | Челябинская область, Миасс | Челябинская область, Миасское | Челябинская область, Миньяр | Челябинская область, Новогорный | Челябинская область, Новосинеглазовский | Челябинская область, Нязепетровск | Челябинская область, Озерск | Челябинская область, Октябрьское | Челябинская область, Первомайский | Челябинская область, Пласт | Челябинская область, Полетаево | Челябинская область, Роза | Челябинская область, Рощино | Челябинская область, Сатка | Челябинская область, Сим | Челябинская область, Снежинск | Челябинская область, Тимирязевский | Челябинская область, Трехгорный | Челябинская область, Троицк | Челябинская область, Тургояк | Челябинская область, Тюбук | Челябинская область, Увельский | Челябинская область, Уйское | Челябинская область, Усть-Катав | Челябинская область, Фершампенуаз | Челябинская область, Чебаркуль | Челябинская область, Чесма | Челябинская область, Южноуральск | Челябинская область, Юрюзань',
	'Запчасти и аксессуары',
	'6-406',
	'Товар от производителя',
	detail["title"],
	'<p>Запчасти для грузовиков и спецтехники в наличии более 150 000 наименований.</p><br><p>Оплата: наличными, онлайн-оплата на сайте или платеж по счету.</p><p>Купон AVITO5 на скидку 5% при заказе с сайта tdbovid.</p><br><p>Доставим за 4 часа или отправим по всей России.</p><p>Доставка по регионам любой ТК: СДЭК, Деловые Линии, ПЭК, КИТ и др.</p><p>Доставка по регионам любой ТК: СДЭК, Деловые Линии, ПЭК, КИТ и др.</p><br><p>Самовывоз со склада по адресам:</p><ul><li>г. Челябинск ул. Линейная, 98;</li><li>г. Челябинск, ул.Троицкий тракт, 66.</li></ul><br><p>Если в нашем магазине на Авито не нашлась нужная запчасть, комплект, машинокомплект, то это не значит, что ее нет на наших складах. Запчастей для грузовиков более 150 000 наименований. Методов их подбора много. Просто позвоните или напишите нам, мы обязательно подберем нужную запчасть быстро и по привлекательной цене.</p><br><p>Компания ТД БОВИД являемся одним из крупнейших поставщиков в России и официальным дилером АО «Автомобильный завод «УРАЛ», ПАО</p><p>«КАМАЗ», ПАО «Автодизель», АО «ЯЗДА», ООО «УАЗ», ООО</p><p>«ИВЕКО-АМТ», ООО «Автоцентр ОСВАР», АО «Гидросила М»,</p><p>представителем 35 отечественных заводов-изготовителей, а также</p><p>IVECO, VOLVO, RENAULT TRUCKS и спецтехнике KOMATSU, HITACHI, </p><p>CATERPILLAR.</p></ul>',
	detail["price"],
	'Новое',
	a,
	links
    ])    
```
**Ну и `САМОЕ ВАЖНОЕ`!!!**
Не забывать увеличивать переменную `start` на `limit`, чтобы вечный цикл не стал действительно вечным
```python
start += limit
```
> В методах для сбера порядок действий такой же. А метод sberMarket_xls нужно внедрить внутрь метода obzhee

## create_EAN13
При вызове метода в него передается уникальный идентификатор запчасти, в начало этого id подставляются нули до тех пор, пока длина строки не станет 12 символов.
Далее идет вычисление контрольного 13 числа:
1. Просуммировать числа на четных позициях
2. Результат п.1 умножить на 3
3. Просуммировать числа на нечетных позициях
4. Сложить результаты п.2 и п.3
5. Вычислить разницу между результатом п.4 и ближайшим к нему наибольшим числом, кратным 10. По сути нужно из 10 вычесть остаток от деления на 10 результата п.4, если тот, в свою очередь, не равен нулю. Если же результат п.4 == 0, то и контрольное число тоже равно нулю.
6. Добавляем контрольное число в конец строки, которую мы создали путем добавления в начало уникального идентификатора нулей и получаем EAN13 (Пока только в теории)
```python
while len(detail_id) < 12:
    detail_id = "0" + detail_id
index = 0
chetnie = 0
nechetnie = 0
for i in detail_id:
    if index in (1,3,5,7,9,11):
        chetnie += int(i)
    else:
        nechetnie += int(i)
    index += 1
result = chetnie * 3 + nechetnie
if result != 0:
    thirteen_char = 10 - (result % 10)
else:
    thirteen_char = 0
detail_id = detail_id + str(thirteen_char)
```
